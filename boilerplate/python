#!/usr/bin/python3

# Copyright 2017-2018 Yury Gribov
# 
# Use of this source code is governed by MIT license that can be
# found in the LICENSE.txt file.

import sys
import os
import os.path
import re
import subprocess
import argparse
import tempfile
import imp
import site

me = os.path.basename(__file__)

def warn(msg):
  sys.stderr.write('%s: warning: %s\n' % (me, msg))

def error(msg):
  sys.stderr.write('%s: error: %s\n' % (me, msg))
  sys.exit(1)

class Re:
  """
  "Regex cacher" which allows doing things like
    if Re.match(...):
      x = Re.group(1)
  """

  last_match = None

  @classmethod
  def match(self, *args, **kwargs):
    self.last_match = re.match(*args, **kwargs)
    return self.last_match

  @classmethod
  def search(self, *args, **kwargs):
    self.last_match = re.search(*args, **kwargs)
    return self.last_match

  @classmethod
  def fullmatch(self, *args, **kwargs):
    self.last_match = re.fullmatch(*args, **kwargs)
    return self.last_match

  @classmethod
  def group(self, *args, **kwargs):
    return self.last_match.group(*args, *kwargs)

  @classmethod
  def groups(self, *args, **kwargs):
    return self.last_match.groups(*args, **kwargs)

def run(args, **kwargs):
  """A dummy wrapper to avoid deadlocks with subprocess.PIPE."""
  if 'abort_on_error' in kwargs:
    abort_on_error = kwargs['abort_on_error']
    del kwargs['abort_on_error']
  else:
    abort_on_error = False
  out_file = tempfile.mktemp()
  err_file = tempfile.mktemp()
  with open(out_file, 'w') as out_fileno, open(err_file, 'w') as err_fileno:
    p = subprocess.Popen(args, stdout=out_fileno, stderr=err_fileno, **kwargs)
    p.communicate()
  with open(out_file, 'r') as f:
    out = f.read()
  os.unlink(out_file)
  with open(err_file, 'r') as f:
    err = f.read()
  os.unlink(err_file)
  if p.returncode != 0 and abort_on_error:
    error("subprocess failed: %s\nStdout:\n%s\nStderr:\n%s" % (" ".join(args), out, err))
  return p, out, err

def ensure_module(module, package=None, user=True, quiet=False):
  """
  A simple function to install module if it's missing.
  Call like
    ensure_module('wx', 'wxPython')
    ensure_module('configparser')
  """
  try:
    imp.find_module(module)
  except ImportError:
    if not quiet:
      print("Installing Python module %s..." % module)
    exe = sys.executable
    if package is None:
      package = module
    try:
      subprocess.check_call([exe, '-mensurepip'])
    except subprocess.CalledProcessError:
      warn("failed to ensure pip")
    subprocess.check_call(
      [exe, '-mpip', 'install'] + (['--user'] if user else []) + [package])
    # User site packages are often not in PATH by default
    for d in (site.getusersitepackages() if user else site.getsitepackages()):
      if d not in sys.path:
        sys.path.append(d)
    try:
      imp.find_module(module)
    except ImportError:
      error("module '%s' not found in package '%s'" % (module, package))

def main():
  parser = argparse.ArgumentParser(description="Generate wrappers for shared library functions.")
  parser.add_argument('library', metavar='LIB', help="Library to be wrapped.")
  parser.add_argument('--verbose', '-v', action='count', help="Print diagnostic info.", default=0)
  parser.add_argument('--dlopen-callback', help="Call user-provided custom callback to dlopen library.")
  parser.add_argument('--dlopen', dest='dlopen', help="Emit dlopen call (user does not need to load library himself).", action='store_true')
  parser.add_argument('--no-dlopen', dest='dlopen', help="Do not emit dlopen call (user must load library himself).", action='store_false')
  parser.set_defaults(dlopen=True)
  parser.add_argument('--library-load-name', help="Use custom name for dlopened library (default is LIB).")
  parser.add_argument('rest', nargs=argparse.REMAINDER, default=[])

  args = parser.parse_args()

if __name__ == '__main__':
  main()
